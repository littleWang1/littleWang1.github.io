---
title: 面试题总结
date: 2024-01-16 10:34:00 +0800
categories: [面试]
tags: [学习]
pin: true
author: 小牛
toc: true
comments: true
math: false
mermaid: true
typora-root-url: ../../littleWang1.github.io
---

# 1.Sychronized的偏向锁、轻量级锁、重量级锁



在jdk1.6版本之前，Sychronized只有重量级锁，而这种锁在使用时，会切换用户状态和操作系统的内核状态，大大提高了系统的性能，所以在后来加入了偏向锁、轻量级锁，这是为了更好的提升系统的性能

# 2什么情况下Interger会自动拆箱

在Java中，当Integer类型的对象需要转换为基本数据类型（如int、double等）时，会发生拆箱操作。以下是几种情况下Integer会进行拆箱：

1. 调用基本数据类型的方法或操作符：例如，将Integer对象与其他基本数据类型相加、相减、相乘等操作时，Integer对象会自动拆箱成对应的基本数据类型。
2. 赋值给基本数据类型变量：当将一个Integer对象赋值给int类型的变量时，会触发拆箱操作。
3. 方法参数需要基本数据类型：如果一个方法的参数是基本数据类型，而你传递给它一个Integer对象作为实参，编译器会自动将Integer对象拆箱为对应的基本数据类型。
4. 比较操作：当使用关系运算符（如==、!=、<、>等）对Integer对象进行比较时，会进行拆箱操作。

需要注意的是，拆箱操作可能会引发NullPointerException异常，特别是当Integer对象为null时进行拆箱操作。因此，在拆箱之前，建议先进行null值的判断。

# 3.String a = ”a“和String a= new String("a")创建字符串的区别

- 直接定义的String a = ”A”，是存储在字符串常量池中的，new String（“A”）是存储在堆内存中的
- 直接定义的String A = “A”，在编译阶段创建，newString（“A”）是在运行时才会创建的
- 直接定义的String A="A",在变量池中只有一个，但是newString（“A”）在堆内存中，只要时创建一个，就会生成一个对象

# 4.jdk、jre、jvm的区别

- jdk是程序员所使用的开发工具包，它包括了编译运行程序的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等
- jre是java运行环境，用来运行java程序的字节码文件，jre中包括了jvm以及jvm所需要的各种工具和资源，与jdk不同的是，他是给普通用户使用的，普通用户只需要安装jre就可以运行java文件
- jvm是java虚拟机，是jre的一部分，他是整个java实现跨平台的最核心的部分，负责运行字节码文件
- 我们写Java代码，⽤txt就可以写，但是写出来的Java代码，想要运⾏，需要先编译成字节码，那就需要编译器，⽽JDK中就包含了编译器javac，编译之后的字节码，想要运⾏，就需要⼀个可以执⾏字节码的程序，这个程序就是JVM（Java虚拟机），专⻔⽤来执⾏Java字节码的。
- JVM在执⾏Java字节码时，需要把字节码解释为机器指令，⽽不同操作系统的机器指令是有可能不⼀样的，所以就导致不同操作系统上的JVM是不⼀样的，所以我们在安装JDK时需要选择操作系统。另外，JVM是⽤来执⾏Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运⾏

# 5.面向对象的四大特性

抽象：

继承：

封装：

多态：

# 6.接口和抽象类的区别



# 7.HashMap的扩容机制

## 1.负载因子

从代码中我们可以看到，在向HashMap中添加元素过程中，如果 元素个数（size）超过临界值（threshold） 的时候，就会进行自动扩容（resize），并且，在扩容之后，还需要对HashMap中原有元素进行rehash，即将原来通中的元素重新分配到新的桶中。

在HashMap中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。

loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，也就是说默认情况下，当HashMap中元素个数达到了容量的3/4的时候就会进行自动扩容。（相见HashMap中傻傻分不清楚的那些概念）

## 2.为什么要扩容呢

扩容需要对其容量进行扩充，并且还要进行rehash，这个过程其实很耗时的，但是我们为什么还要扩容呢？这是因为根据hash函数计算出来的地址，有可能出现hash碰撞，HashMap是由数组+链表构成的，这个时候可以将数据放到链表上，我们可以把树一直挂到链表上，但是这时候有个问题，链表如果太长的话，那么数据的查询就像在链表上一样了，链表的查询速度非常低，所以为了保证HashMap的读取速度，我们要想办法尽量保证HashMap的冲突不要太高。

## 3.如何保证HashMap的冲突不会太高呢？

冲突太高无非两种情况：

1. 数组长度太短
2. hash函数设计的不够合理，导致将数据分到同一个或者几个桶中，分配不均

所以解决Hsah碰撞也是从这两方面入手。

为了避免哈希碰撞，HashMap需要在合适的时候进行扩容，需要设置一个合适的负载因子

## 4.负载因子设置多少合适呢？

在JDK官方文档中有一段描述，一般来说，默认的负载因子（0.75）在时间和空间成本上提供了较好的权衡，所以最好的负载因子的值是0.75
